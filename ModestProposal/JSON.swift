//
// JSON.swift
// ModestProposal
//
// Copyright (c) 2014 Justin Kolb - http://franticapparatus.net
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

import Foundation

struct KeyPath : Printable, Equatable {
    let keys: [String]
    
    init(_ path: String) {
        keys = path.componentsSeparatedByString(".")
    }
    
    var length: Int {
        return keys.count
    }
    
    var description: String {
        return keys.description
    }
    
    var string: String {
        return (keys as NSArray).componentsJoinedByString(".")
    }
}

func ==(lhs: KeyPath, rhs: KeyPath) -> Bool {
    return lhs.keys == rhs.keys
}

struct IndexPath : Printable, Equatable {
    let indices: [Int]
    
    init(_ index: Int...) {
        indices = index
    }
    
    var length: Int {
        return indices.count
    }
    
    var description: String {
        return indices.description
    }
}

func ==(lhs: IndexPath, rhs: IndexPath) -> Bool {
    return lhs.indices == rhs.indices
}

enum JSONValue {
    case Object(NSDictionary)
    case Array(NSArray)
    case Number(NSNumber)
    case String(NSString)
    case Null
}

@objc protocol JSONConvertible {
    var json: JSON { get }
}

extension NSDictionary : JSONConvertible {
    var json: JSON {
        return JSON(value: .Object(self))
    }
}

extension NSArray : JSONConvertible {
    var json: JSON {
        return JSON(value: .Array(self))
    }
}

extension NSNumber : JSONConvertible {
    var json: JSON {
        return JSON(value: .Number(self))
    }
}

extension NSString : JSONConvertible {
    var json: JSON {
        return JSON(value: .String(self))
    }
}

extension NSNull : JSONConvertible {
    var json: JSON {
        return JSON(value: .Null)
    }
}

extension NSSet : JSONConvertible {
    var json: JSON {
        return JSON(value: .Array(self.allObjects))
    }
}

@objc class JSON {
    let value: JSONValue
    
    class func parse(data: NSData, options: NSJSONReadingOptions = NSJSONReadingOptions(0)) -> JSON {
        if let json = JSON.parse(data, options: options, error: nil) {
            return json
        } else if (options & NSJSONReadingOptions.MutableContainers) == NSJSONReadingOptions.MutableContainers {
            return JSON.mutableObject()
        } else {
            return JSON.Object()
        }
    }
    
    class func parse(data: NSData, options: NSJSONReadingOptions, error: NSErrorPointer) -> JSON? {
        if let anyObject: AnyObject = NSJSONSerialization.JSONObjectWithData(data, options: options, error: error) {
            switch anyObject {
            case let convertible as JSONConvertible:
                return convertible.json
            default:
                fatalError("All values generated by NSJSONSerialization should be JSONConvertible")
            }
        } else {
            return nil
        }
    }
    
    init(value: JSONValue) {
        self.value = value
    }
    
    class func Null() -> JSON {
        return JSON(value: .Null)
    }
    
    class func Object() -> JSON {
        return JSON(value: .Object(NSDictionary()))
    }
    
    class func mutableObject() -> JSON {
        return JSON(value: .Object(NSMutableDictionary()))
    }
    
    class func Array() -> JSON {
        return JSON(value: .Array(NSArray()))
    }
    
    class func mutableArray() -> JSON {
        return JSON(value: .Array(NSMutableArray()))
    }
    
    subscript(key: String) -> JSON {
        get {
            switch value {
            case let .Object(dictionary):
                switch dictionary[key] {
                case let convertible as JSONConvertible:
                    return convertible.json
                default:
                    return JSON.Null()
                }
            default:
                return JSON.Null()
            }
        }
        set {
            switch value {
            case let .Object(dictionary):
                switch dictionary {
                case let mutableDictionary as NSMutableDictionary:
                    switch newValue.value {
                    case let .Object(object):
                        mutableDictionary.setObject(object, forKey: key)
                    case let .Array(array):
                        mutableDictionary.setObject(array, forKey: key)
                    case let .Number(number):
                        mutableDictionary.setObject(number, forKey: key)
                    case let .String(string):
                        mutableDictionary.setObject(string, forKey: key)
                    case .Null:
                        mutableDictionary.setObject(NSNull(), forKey: key)
                    }
                default:
                    fatalError("Object is not mutable")
                }
            default:
                fatalError("Value is not an object")
            }
        }
    }
    
    subscript(keyPath: KeyPath) -> JSON {
        if keyPath.length == 0 { return JSON.Null() }
        var value = self
        
        for key in keyPath.keys {
            value = value[key]
        }
        
        return value
    }
    
    subscript(index: Int) -> JSON {
        get {
            switch value {
            case let .Array(array):
                switch array[index] {
                case let convertible as JSONConvertible:
                    return convertible.json
                default:
                    return JSON.Null()
                }
            default:
                return JSON.Null()
            }
        }
        set {
            switch value {
            case let .Array(array):
                switch array {
                case let mutableArray as NSMutableArray:
                    switch newValue.value {
                    case let .Object(object):
                        mutableArray.replaceObjectAtIndex(index, withObject: object)
                    case let .Array(array):
                        mutableArray.replaceObjectAtIndex(index, withObject: array)
                    case let .Number(number):
                        mutableArray.replaceObjectAtIndex(index, withObject: number)
                    case let .String(string):
                        mutableArray.replaceObjectAtIndex(index, withObject: string)
                    case .Null:
                        mutableArray.replaceObjectAtIndex(index, withObject: NSNull())
                    }
                default:
                    fatalError("Array is not mutable")
                }
            default:
                fatalError("Value is not an array")
            }
        }
    }
    
    subscript(indexPath: IndexPath) -> JSON {
        if indexPath.length == 0 { return JSON.Null() }
        var value = self
        
        for index in indexPath.indices {
            value = value[index]
        }
        
        return value
    }
    
    func set(key: String, convertible: JSONConvertible) {
        self[key] = convertible.json
    }
    
    func set(index: Int, convertible: JSONConvertible) {
        self[index] = convertible.json
    }
    
    func add(convertible: JSONConvertible) {
        switch value {
        case let .Array(array):
            switch array {
            case let mutableArray as NSMutableArray:
                switch convertible.json.value {
                case let .Object(object):
                    mutableArray.addObject(object)
                case let .Array(array):
                    mutableArray.addObject(array)
                case let .Number(number):
                    mutableArray.addObject(number)
                case let .String(string):
                    mutableArray.addObject(string)
                case .Null:
                    mutableArray.addObject(NSNull())
                }
            default:
                fatalError("Array is not mutable")
            }
        default:
            fatalError("Value is not an array")
        }
    }
    
    func remove(key: String) {
        switch value {
        case let .Object(dictionary):
            switch dictionary {
            case let mutableDictionary as NSMutableDictionary:
                mutableDictionary.removeObjectForKey(key)
            default:
                fatalError("Object is not mutable")
            }
        default:
            fatalError("Value is not an object")
        }
    }
    
    func remove(index: Int) {
        switch value {
        case let .Array(array):
            switch array {
            case let mutableArray as NSMutableArray:
                mutableArray.removeObjectAtIndex(index)
            default:
                fatalError("Array is not mutable")
            }
        default:
            fatalError("Value is not an array")
        }
    }
    
    var count: Int {
        switch value {
        case let .Object(dictionary):
            return dictionary.count
        case let .Array(array):
            return array.count
        default:
            return 0
        }
    }
    
    var object: NSDictionary {
        return object(otherwise: NSDictionary())
    }
    
    func object(# otherwise: NSDictionary) -> NSDictionary {
        switch value {
        case let .Object(dictionary):
            return dictionary
        default:
            return otherwise
        }
    }
    
    var array: NSArray {
        return array(otherwise: NSArray())
    }
    
    func array(# otherwise: NSArray) -> NSArray {
        switch value {
        case let .Array(array):
            return array
        default:
            return otherwise
        }
    }
    
    var number: NSNumber {
        return number(otherwise: NSNumber())
    }
    
    func number(# otherwise: NSNumber) -> NSNumber {
        switch value {
        case let .Number(number):
            return number
        default:
            return otherwise
        }
    }
    
    var string: NSString {
        return string(otherwise: "")
    }
    
    func string(# otherwise: NSString) -> NSString {
        switch value {
        case let .String(string):
            return string
        default:
            return otherwise
        }
    }
    
    var isNull: Bool {
        switch value {
        case .Null:
            return true
        default:
            return false
        }
    }
}

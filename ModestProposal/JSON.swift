//
// JSON.swift
// ModestProposal
//
// Copyright (c) 2014 Justin Kolb - http://franticapparatus.net
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

import Foundation

public enum JSONValue {
    case Object(NSDictionary)
    case Array(NSArray)
    case Number(NSNumber)
    case String(NSString)
    case Null
}

@objc public protocol JSONConvertible {
    var json: JSON { get }
}

extension NSDictionary : JSONConvertible {
    public var json: JSON {
        return JSON(value: .Object(self))
    }
}

extension NSArray : JSONConvertible {
    public var json: JSON {
        return JSON(value: .Array(self))
    }
}

extension NSNumber : JSONConvertible {
    public var json: JSON {
        return JSON(value: .Number(self))
    }
}

extension NSString : JSONConvertible {
    public var json: JSON {
        return JSON(value: .String(self))
    }
}

extension NSNull : JSONConvertible {
    public var json: JSON {
        return JSON(value: .Null)
    }
}

@objc public final class JSON : Printable {
    let value: JSONValue
    
    public class func parse(data: NSData, options: NSJSONReadingOptions, error: NSErrorPointer) -> JSON? {
        if let anyObject: AnyObject = NSJSONSerialization.JSONObjectWithData(data, options: options, error: error) {
            switch anyObject {
            case let convertible as JSONConvertible:
                return convertible.json
            default:
                fatalError("All values generated by NSJSONSerialization should be JSONConvertible")
            }
        } else {
            return nil
        }
    }
    
    public func format(prettyPrinted: Bool = false) -> NSData {
        var obj: AnyObject!
        
        switch value {
        case let .Array(array):
            obj = array
        case let .Object(object):
            obj = object
        case let .Number(number):
            obj = number
        case let .String(string):
            obj = string
        case .Null:
            obj = NSNull()
        }

        var error: NSError?
        let options = prettyPrinted ? NSJSONWritingOptions.PrettyPrinted : NSJSONWritingOptions.allZeros
        if let data = NSJSONSerialization.dataWithJSONObject(obj, options: options, error: &error) {
            return data
        } else {
            println(error)
            fatalError("Unable to format JSON")
        }
    }
    
    public init(value: JSONValue) {
        self.value = value
    }
    
    public class func null() -> JSON {
        return JSON(value: .Null)
    }
    
    public class func object() -> JSON {
        return JSON(value: .Object(NSMutableDictionary()))
    }
    
    public class func array() -> JSON {
        return JSON(value: .Array(NSMutableArray()))
    }
    
    public var description: String {
        switch value {
        case let .Array(array):
            return array.description
        case let .Object(object):
            return object.description
        case let .Number(number):
            return number.description
        case let .String(string):
            return string.description
        case .Null:
            return "null"
        }
    }
    
    public subscript(key: String) -> JSON {
        get {
            switch value {
            case let .Object(dictionary):
                switch dictionary[key] {
                case let convertible as JSONConvertible:
                    return convertible.json
                default:
                    return JSON.null()
                }
            default:
                return JSON.null()
            }
        }
        set {
            switch value {
            case let .Object(dictionary):
                switch dictionary {
                case let mutableDictionary as NSMutableDictionary:
                    switch newValue.value {
                    case let .Object(object):
                        mutableDictionary.setObject(object, forKey: key)
                    case let .Array(array):
                        mutableDictionary.setObject(array, forKey: key)
                    case let .Number(number):
                        mutableDictionary.setObject(number, forKey: key)
                    case let .String(string):
                        mutableDictionary.setObject(string, forKey: key)
                    case .Null:
                        mutableDictionary.setObject(NSNull(), forKey: key)
                    }
                default:
                    fatalError("Object is not mutable")
                }
            default:
                fatalError("Value is not an object")
            }
        }
    }
    
    public subscript(keyPath: KeyPath) -> JSON {
        if keyPath.length == 0 { return JSON.null() }
        var value = self
        
        for key in keyPath.keys {
            value = value[key]
        }
        
        return value
    }
    
    public subscript(index: Int) -> JSON {
        get {
            switch value {
            case let .Array(array):
                switch array[index] {
                case let convertible as JSONConvertible:
                    return convertible.json
                default:
                    return JSON.null()
                }
            default:
                return JSON.null()
            }
        }
        set {
            switch value {
            case let .Array(array):
                switch array {
                case let mutableArray as NSMutableArray:
                    switch newValue.value {
                    case let .Object(object):
                        mutableArray.replaceObjectAtIndex(index, withObject: object)
                    case let .Array(array):
                        mutableArray.replaceObjectAtIndex(index, withObject: array)
                    case let .Number(number):
                        mutableArray.replaceObjectAtIndex(index, withObject: number)
                    case let .String(string):
                        mutableArray.replaceObjectAtIndex(index, withObject: string)
                    case .Null:
                        mutableArray.replaceObjectAtIndex(index, withObject: NSNull())
                    }
                default:
                    fatalError("Array is not mutable")
                }
            default:
                fatalError("Value is not an array")
            }
        }
    }
    
    public func set(key: String, convertible: JSONConvertible) {
        self[key] = convertible.json
    }
    
    public func replace(index: Int, convertible: JSONConvertible) {
        self[index] = convertible.json
    }
    
    public func add(convertible: JSONConvertible) {
        switch value {
        case let .Array(array):
            switch array {
            case let mutableArray as NSMutableArray:
                switch convertible.json.value {
                case let .Object(object):
                    mutableArray.addObject(object)
                case let .Array(array):
                    mutableArray.addObject(array)
                case let .Number(number):
                    mutableArray.addObject(number)
                case let .String(string):
                    mutableArray.addObject(string)
                case .Null:
                    mutableArray.addObject(NSNull())
                }
            default:
                fatalError("Array is not mutable")
            }
        default:
            fatalError("Value is not an array")
        }
    }
    
    public func removeKey(key: String) {
        switch value {
        case let .Object(dictionary):
            switch dictionary {
            case let mutableDictionary as NSMutableDictionary:
                mutableDictionary.removeObjectForKey(key)
            default:
                fatalError("Object is not mutable")
            }
        default:
            fatalError("Value is not an object")
        }
    }
    
    public func removeIndex(index: Int) {
        switch value {
        case let .Array(array):
            switch array {
            case let mutableArray as NSMutableArray:
                mutableArray.removeObjectAtIndex(index)
            default:
                fatalError("Array is not mutable")
            }
        default:
            fatalError("Value is not an array")
        }
    }
    
    public var count: Int {
        switch value {
        case let .Object(dictionary):
            return dictionary.count
        case let .Array(array):
            return array.count
        default:
            return 0
        }
    }
    
    public var asNumber: NSNumber? {
        switch value {
        case let .Number(number):
            return number
        default:
            return nil
        }
    }
    
    public var asString: String? {
        switch value {
        case let .String(string):
            return string as? String
        default:
            return nil
        }
    }
    
    public var asArray: [AnyObject]? {
        switch value {
        case let .Array(array):
            return array as [AnyObject]
        default:
            return nil
        }
    }
    
    public var asStringArray: [String]? {
        if let array = asArray {
            var strings: [String] = []
            for object in array {
                if let string = object as? String {
                    strings.append(string)
                } else {
                    return nil
                }
            }
            return strings
        } else {
            return nil
        }
    }
    
    public var asSecondsSince1970: NSDate? {
        if let number = asNumber {
            return NSDate(timeIntervalSince1970: number.doubleValue)
        } else {
            return nil
        }
    }
    
    public var asURL: NSURL? {
        if let string = asString {
            let length = Swift.count(string)
            return length == 0 ? nil : NSURL(string: string)
        } else {
            return nil
        }
    }
    
    public var asUnescapedString: String? {
        if let string = asString {
            return string.unescapeEntities()
        } else {
            return nil
        }
    }
    
    public var asDouble: Double? {
        if let number = asNumber {
            return number.doubleValue
        } else {
            return nil
        }
    }
    
    public var asInteger: Int? {
        if let number = asNumber {
            return number.integerValue
        } else {
            return nil
        }
    }
    
    public var asBoolean: Bool? {
        if let number = asNumber {
            return number.boolValue
        } else {
            return nil
        }
    }

    public var isNull: Bool {
        switch value {
        case .Null:
            return true
        default:
            return false
        }
    }
    
    public var isObject: Bool {
        switch value {
        case .Object:
            return true
        default:
            return false
        }
    }
    
    public var isArray: Bool {
        switch value {
        case .Array:
            return true
        default:
            return false
        }
    }
    
    public var isString: Bool {
        switch value {
        case .String:
            return true
        default:
            return false
        }
    }
    
    public var isNumber: Bool {
        switch value {
        case .Number:
            return true
        default:
            return false
        }
    }
}
